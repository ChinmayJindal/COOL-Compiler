README file for Programming Assignment 4 (C++ edition)
======================================================

Your directory should now contain the following files:

 Makefile		-> [course dir]/assignments/PA4/Makefile
 README
 ast-lex.cc		-> [course dir]/src/PA4/ast-lex.cc
 ast-parse.cc		-> [course dir]/src/PA4/ast-parse.cc
 bad.cl
 cgen			-> [course dir]/etc/../lib/.i
 cool-tree.cc		-> [course dir]/src/PA4/cool-tree.cc
 cool-tree.h
 cool-tree.handcode.h
 dumptype.cc		-> [course dir]/src/PA4/dumptype.cc
 good.cl
 handle_flags.cc	-> [course dir]/src/PA4/handle_flags.cc
 mycoolc		-> [course dir]/src/PA4/mycoolc
 mysemant		-> [course dir]/src/PA4/mysemant
 semant-phase.cc	-> [course dir]/src/PA4/semant-phase.cc
 semant.cc
 semant.h
 stringtab.cc		-> [course dir]/src/PA4/stringtab.cc
 symtab_example.cc	-> [course dir]/src/PA4/symtab_example.cc
 tree.cc		-> [course dir]/src/PA4/tree.cc
 utilities.cc		-> [course dir]/src/PA4/utilities.cc
 *.d			  dependency files

The include (.h) files for this assignment can be found in 
[course dir]/include/PA4

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.

	good.cl and bad.cl test a few features of the semantic checker.
	You should add tests to ensure that good.cl exercises as many
	legal semantic combinations as possible and that bad.cl
	exercises as many kinds of semantic errors as possible.

	semant.h contains declarations and definitions for the semantic
	analyzer.  Place class definitions for the structures you will
	use here.

	cool-tree.aps contains the definitions for the tree language
	which you use to construct the abstract syntax tree (AST).
	From this file, cool-tree.h and cool-tree.cc are automatically 
        generated by a utility that compiles the specification into
        C++ functions for producing and consuming the tree nodes.
        This file is provided for your reference.  DO NOT MODIFY.

        tree.{cc|h} contain definitions used by the tree package.  DO
        NOT MODIFY.

        cool-tree.h, and cool-tree.handcode.h specify and give an
        implementation of Cool ASTs (see the README for PA3 and the
        "Cool Tour").  In this assignment, you will need to add
        functions to the AST classes to store, fetch, and compute
        information about the AST.  Note that cool-tree.handcode.h
        differs slightly from the file supplied for PA3.

   	You should NOT remove any definitions that are already present
	in cool-tree.h and cool-tree.handcode.h.  These functions and
	data members are required for the system to function properly.

        You should add any fields and methods to the classes you need to 
	perform semantic analysis.  You	will need to add, for example, 
	methods which traverse the expressions of the tree and implement 
	the type-checking rules.

	cool-tree.cc contains definitions of the provided methods,
	and instantiations of the template for the list handling functions.
	You should not modify this file, but place definitions of all
	methods you add to cool-tree.h or cool-tree.handcode.h in semant.cc.
	DO NOT MODIFY cool-tree.cc

	semant.cc is the file in which you should write your semantic
	analyzer.  The main() procedure calls the method `semant'
	on `ast_root', the root of the abstract syntax tree generated by
	the parser.  There are methods supplied that you should use to report 
	errors. You are relatively free in how you decide to structure the 
	semantic checker, but don't modify the error printing routines.

	ast-lex.cc and ast-parse.cc implement a lexer and a parser for
	reading text representation of ASTs from console in the format
	produced by the parser phase. DO NOT MODIFY.

	semant-phase.cc contains a test driver for semantic analysis.
	The main program reads an AST in text form from standard input,
	parses it, and then produces a type-annotated AST on standard
	output.  The script mycoolc can pass any of the standard flags
	to the semantic analyzer as well; for this assignment, -s
	(semantic analysis debug) may be useful as it sets a global
	variable semant_debug to true (1).  If you want your semantic
	checker to print debug information when the option is set, write
	your debug code in the following format:

	      if (semant_debug)
	      {
		...
	      }

	semant_debug is provided as a convenience. You don't need to use
	the debugging flags if you don't want to. DON'T MODIFY
	semant-phase.cc

	symtab.h contains a symbol table implementation. Read the
	comments in the file, the "Cool Tour", and look at the example
	in symtab_example.cc.  You are not required to use this code,
	but you may find it useful. DO NOT MODIFY.

Instructions
------------

	To compile the example use of the symbol table, type

	% make symtab_example
        % ./symtab_example

	To compile your semantic analyzer program type:

	% make semant

	To test your semantic checker, type:

        % ./mysemant good.cl

	mysemant is a version of mycoolc that omits code generation.
	mysemant parses all the cool files given on the command line and
	builds a single abstract syntax tree containing all class
	definitions appearing in the input files. Your semantic checker
	is then called on this abstract syntax tree.  If there are no
	errors, the program produces a type-annotated abstract syntax
	tree as output.

	To run your checker on the files good.cl and bad.cl type:

	% make dotest

	If you think your semantic checker is correct and behaves like
	the one we wrote, you can try to run mycoolc using your checker,
	your parser and also your lexical analyzer if you choose (see
	below for instructions).  Remember if your lexer, parser or
	checker behaves in an unexpected manner, you may get errors
	anywhere.


        Instructions for turning in the assignment will be posted on the
        course web page.

        GOOD LUCK!

Design Details
--------------
The semantic analyser does all the type checking conforming to the rules
of Cool Grammar which have been taken from the Cool Manual. The phase 
has been divided into two phases - The first phase builds the inheritance
graph and checks for its validity. The second phase contains most of the
type checking for each feature of classes and the expressions which form
most part of the Cool grammar.

	Phase I
	=======
	Here the inheritance graph of the Cool program is constructed. First, the
	basic classes Object (ancestor of all Classes in Cool), Int, Bool, String
	and IO classes are added to the graph. The graph is an STL Map which maps
	from the name of the class (type Symbol) to the object of the class (type Class_).
	It has been declared in semant.h.

	The classtable constructor is the place where the graph is first populated
	and then checks are done on that graph. Here, we iterator over each of the 
	user defined classes and check for their name and inheritance validity.
	The rules for defining a class are:
		1.) Name of class cannot be 'self'
		2.) Class cannot be redefined with same name
		3.) Class cannot inherit SELF_TYPE or any of the basic classes
		4.) There should be one and only one 'Main' class.

	After the 'classGraph' map has been populated with valid checks using the
	above rules, we must check for any inheritance cycles. This has been
	checked using the two pointer cycle checking method in a linked list ( as
	Cool does not allow multiple-inheritance, so this method will work because
	each class has only one parent at most ). In this routine, it is also
	verified that the inherited parent is a valid defined class in the classes list.

	At every step of the iteration of the cycle checking method, we verify that
	whether we have reached the top of the inheritance graph (the 'Object' method).
	The condition whether there exists a cycle or not will be when the two pointers
	start pointing to the same Symbol. This is an error because we don't want any
	cycles in out inheritance graph because this will cause confusion at later stages 
	when we want to play with inherited attributes.

	All the error messages for this phase are kept as close as possible to the 
	original Cool Semantic analyser.

	Phase II
	========
	In this phase the type checking for the features of the classes takes place. For
	every class we build a new symbol table for both the methods and attributes to be
	populated for that class. We recursively populate the hierarchy of all methods
	and attributes for that class starting from the seniormost class (the 'Object')
	class. This has been done using the 'build_hierarchy' method. This is done so that
	all attributes and methods which should be in the scope of the class are retrieved
	at once. Here is a general explanation of the 'build_hierarchy' method:
		1.) Recursively reach the top of the inheritance graph starting from a given 
			class.
		2.) Enter a new scope in both methods and attributes symbol tables.
		3.) Iterate over the features list of the current class and add to respective
			tables. For this a new member method of 'Feature' class called 'toSymTab'
			has been added for both child classes 'method_class' and 'attr_class'. 
			These are respectively called based on whether the current feature is
			a method or an attribute.

	Adding Methods to Symbol Table
	------------------------------
	The method 'toSymTab' has been overridden from the base class 'Feature_class' in the
	'method_class'. Here are rules which have been used to populate the symbol table.
		1.) A method name cannot be multiply defined in the same scope.
		2.) If a method is redefined despite being declared already in an ancestor class,
			the old definition will be overridden. But the overriding is valid only if
			the return type and the formals list match exactly as in the ancestor. This
			has been checked with appropriate error messages by first checking the
			number of formals in the redefined method and the inherited method. Then
			the return type match is checked. In case all conditions are valid, it is
			added to the symbol table.
		3.) In case of no collisions, anyways, it is added to the symbol table of methods.

	Adding Attributes to Symbol Table
	---------------------------------
	The method 'toSymTab' has been overridden from the base class 'Feature_class' in the
	'attr_class'. Here are rules which have been used to populate the symbol table.
		1.) 'self' cannot be the name of an attibute.
		2.) Attribute cannot be redefined in the same scope.
		3.) Attribute cannot be redefined if already defined in an ancestor.
		4.) The type of an attribute can be SELF_TYPE.

	This completes building the hierarchy and now we know what all methods and
	attributes are in the scope of current class. Now we must validate each
	feature of the class which is done by looping over all the features. The
	entry and exit of the loop is done by entering scope ('enterscope()') and
	exiting ('exitscope()') every time a new feature is evaluated. All validation
	is done inside a method called 'validate' which has been overriden from the
	parent class 'Expression_class' in each of the child classes for expressions,
	methods and attributes.

	Validating Methods
	------------------
	Methods have been validated in the 'method_class' overriden method 'validate'.
	Here are the rules used:
		1.) The 'main' method in the 'Main' class must have no arguments.
		2.) In other cases, we must iterate over all the formals and check following:
			i.) 'self' cannot be name of a parameter
			ii.) Paramter cannot be 'SELF_TYPE'
			iii.) Parameter must not be multiply defined
		3.) Then the expression of the methods must be evaluated for type checking.
		4.) The return type of the evaluated expression must be equal to the declared
			type.
		5.) The evaluated return type (from expression) can be a child type of the
			declared return type.

	Validating Attributes
	---------------------
	Methods have been validated in the 'method_class' overriden method 'validate'.
	Here are the rules used:
		1.) First the assigning expression must be validated (discussed later)
		2.) The declared type of the attribute must be a valid existing type.
		3.) The return type of the assigning expression can be the same or an
			inherited type from the declared type of the variable.

	Validating Assignment ( <id> = <expr> ) 
	---------------------------------------
	The assignment operation is validated in the 'method_class' overriden method 
	'validate'. Here are the rules used.
		1.) The left side name of the attribute must be a valid name in current
			scope or the scope of ancestors. (checked using 'lookup' method)
		2.) The type of the expression of the right side must be a valid inherited
			type of the declared type of the attribute on the left.
		3.) The return type is the type of the expression on the right if it is
			valid otherwise 'Object'.

	Validating Static Dispatch ( <expr>@<type_name>.<name>(<actual>) ) 
	------------------------------------------------------------------
	The static dispatch is validated in the 'static_dispatch_class' overriden method
	'validate'. Here are the rules used.
		1.) The class whose method is being called (type_name) must be a valid
			declared class.
		2.) The method being dispatched should be a valid method in the 
			hierarchy of the current class.
		3.) The value of the formals of the method called must match exactly
			the method being called in the class type_name.
		4.) The type of the expr must be a valid child type of the class type_name.
		5.) The return type of static dispatch is the type of the expression.

	Validating Dispatch ( <type_name>.<name>(<actual>) ) 
	----------------------------------------------------
	The dispatch is validated in the 'static_dispatch_class' overriden method
	'validate'. All rules in the static dispatch must be conformed to and
	the method must be a valid method in the scope of the hierarchy of the
	given class.

	Validation Condition ( if <pred> then <then_expr> else <else_expr> )
	--------------------------------------------------------------------
	The if condition is validated in the 'cond_class' overriden method
	'validate'. Here are the rules used:
		1.) The type of the pred should be Bool
		2.) The return type of the if condition is the closest ancestor
			of the types of then_expr and else_expr. This is technically
			called the 'join' of the two classes.

	Validating Loop ( while <pred> loop <body> pool )
	-------------------------------------------------
	The while loop is validated in the 'loop_class' overriden method
	'validate'. Here are the rules used:
		1.) The type of the pred expression must be Bool.
		2.) The return type of the loop is Object.
		3.) The body must be validated as earlier.

	Validating Case ( case [<id>:<type> [<- <expr>]]+ of [<id>:<type> => <expr>]+ esac )
	------------------------------------------------------------------------------------
	The case statement is validated in the 'typcase_class' overriden method
	'validate'. Here are the rules used:	
		1.) First the expr must be validated
		2.) Each of the branch case must have a valid type in current hierarchy.
		3.) Two branch statements cannot have the same type.
		4.) The return type of the expression type of the branch expression
			must be a valid child class of the declared type of the branch.
		5.) The return type of the case statements is the 'join' of all the types
			of the branches.

	Validating Block ( { <body> } )
	-------------------------------
	The block statement is validated in the 'block_class' overriden method
	'validate'. Here are the rules used:
		1.) Each of the statement in the body is evaluated.
		2.) The return type of the block statement is the type of the last
			expression statement in block.

	Validating Let ( { let <identifier>:<type_decl> in <body> } )
	-------------------------------------------------------------
	The block statement is validated in the 'let_class' overriden method
	'validate'. Here are the rules used:
		1.) No identifier in the let can have name 'self'
		2.) Initialization expression is evaluated. A new scope is entered.
		3.) The type declaration and the assigned expression must be a valid
			sub class of the declared type.
		4.) The type of the 'let' statement is the type of the body.

	Validating Operators ( +,-,*,/,<,<=,~ )
	---------------------------------------
	The operator statements are validated in their respective overriden method
	'validate'. Here are the rules used:
		1.) The left and right expressions are evaluated.
		2.) Both must be of type Int.
		3.) The return type in case of <, <= is Bool. Otherwise it is Int.
	
	Validating Equality ( =,<,<=,not )
	----------------------------------
	The inequality statements are validated their classes overriden method
	'validate'. Here are the rules used:
		1.) The left and right expression types must be equal.
		2.)	The expression types can only be Int, Bool or String
		3.) '<' and '<=' can only have Int in both expression types
		4.) 'not' can
		4.) The return type is Bool (Object on error)

	Validating 'new'
	----------------
	The 'new' statement is validated in 'new__class' verriden method 'validate'. 
	Here are the rules used:
		1.) The class must be a valid declared type in the inheritance graph.
		2.) Return type is the type of the class.
